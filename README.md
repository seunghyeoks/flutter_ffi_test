# Flutter FFI test

This is a sample project to test running golang code in a Flutter app, using `cgo` and `dart:ffi`.

I'm not sure if this is completely accurate, but first, Golang has a solution called `cgo` that provides compatibility with the C language.

And dart's `FFI` provides compatibility between C code and Dart.

So, it seems that if you build your Golang source code as a C-compatible native library, and then import this library via FFI, you can run code written in Golang on Dart.

## Project structure

This project mainly consists of the following parts:

* `src`: Contains go code with simple functions defined, C compatibility code for that go code, a Makefile, etc.

* `lib`: Contains the Dart code that defines the API of the plugin, and which
  calls into the native code using `dart:ffi`.

* `example`: Contains the example Flutter project for App contents. Import plugin code as a package and run the function.

* platform folders (`android`, `ios`, `windows`, etc.): Contains the build files
  for building and bundling the native code library with the platform application.


## How to Build

1. Install Flutter, and use the `flutter doctor` command to check it out.

2. open project in Terminal and run `cd src; make build; make android; make ios;`

3. `cd ..` to move root directory of project

4. In terminal, type and run `dart run ffigen --config ffigen.yaml`

5. `cd example` and run `flutter run`

entire command will be 
```sh
cd src; 
make build; make android; make ios; 
cd ..; 
dart run ffigen --config ffigen.yaml; 
cd example; 
flutter run
```

## References

* [flutter online docs: c-interop](https://docs.flutter.dev/development/platform-integration/c-interop), It will provide more accurate and diverse information


## Building and bundling native code (instruction generated by FFI)

The `pubspec.yaml` specifies FFI plugins as follows:

```yaml
  plugin:
    platforms:
      some_platform:
        ffiPlugin: true
```

This configuration invokes the native build for the various target platforms
and bundles the binaries in Flutter applications using these FFI plugins.

This can be combined with dartPluginClass, such as when FFI is used for the
implementation of one platform in a federated plugin:

```yaml
  plugin:
    implements: some_other_plugin
    platforms:
      some_platform:
        dartPluginClass: SomeClass
        ffiPlugin: true
```

A plugin can have both FFI and method channels:

```yaml
  plugin:
    platforms:
      some_platform:
        pluginClass: SomeName
        ffiPlugin: true
```

The native build systems that are invoked by FFI (and method channel) plugins are:

* For Android: Gradle, which invokes the Android NDK for native builds.
  * See the documentation in android/build.gradle.
* For iOS and MacOS: Xcode, via CocoaPods.
  * See the documentation in ios/fa_golang.podspec.
  * See the documentation in macos/fa_golang.podspec.
* For Linux and Windows: CMake.
  * See the documentation in linux/CMakeLists.txt.
  * See the documentation in windows/CMakeLists.txt.

## Binding to native code (instruction generated by FFI)

To use the native code, bindings in Dart are needed.
To avoid writing these by hand, they are generated from the header file
(`src/fa_golang.h`) by `package:ffigen`.
Regenerate the bindings by running `dart run ffigen --config ffigen.yaml`.

## Invoking native code (instruction generated by FFI)

Very short-running native functions can be directly invoked from any isolate.
For example, see `sum` in `lib/fa_golang.dart`.

Longer-running functions should be invoked on a helper isolate to avoid
dropping frames in Flutter applications.
For example, see `sumAsync` in `lib/fa_golang.dart`.

